Handle in MPI_Status:
 - Checking for MPI_PROC_NULL for source
 - Checking for MPI_ANY_TAG as tag

MPI_Get_library_version string length stuff.

Possibly you need to convert errorcodes in some functions.
- Error codes for DATAREP stuff.

New constants:
 - MPI_MAX_DATAREP_STRING (must be at least 64)
 - MPI_MAX_OBJECT_NAME (must be at least 64)
 - MPI_MAX_PORT_NAME
 - MPI_MESSAGE_NO_PROC
 this is a function conv_onesided_constants
 - MPI_COMM_TYPE_SHARED
 - MPI_REPLACE
 - MPI_NO_OP
 - MPI_ARGVS_NULL as pointer
 - MPI_THREAD_*

- MPI_ERR_SPAWN
- MPI_ERR_PORT

For arrays where conversions must happen, need to establish dimensions.
MPI_Comm_spawn and MPI_Comm_spawn_multiple are doom-a-licious.
Handle c2f and f2c functions.

MPI_Type_match_size does predefined stuff.

Special cases:

MPI_Init
MPI_Init_thread
MPI_Finalize

Do validate on MPI handles and check if they're MPI_BLAH_NULL or MPI_GROUP_EMPTY for input and output.

classes:

error
amode
comparison
provided
topo
onesided
locktype
whence
threadmodel

MPI_Test and all the various request-ola crap.
MPI_Type_create_darray
MPI_Type_get_envelope crap

If you have a pure output object that is a handle, just instantiate the handle up front and then add it on the backend.
Need to handle converting MPI_Requests.

Check functions that have errorcodes as arguments.
