import xml.etree.ElementTree as ET
import sys
import glob
import os
import fileinput
import shutil
import tempfile
import re
import subprocess
import sqlite3

## Contains an assortment of I/O and system manipulation methods common to AV 
#  python scripts and classes.  Call static methods to access them.
class AVUtility:
    ## Send the given command to the shell.
    # @param cmd Command to be executed by the shell.
    # @return None
    @staticmethod
    def executeCommand(cmd):
        try:
            subprocess.check_call(cmd, shell=True, executable="/bin/bash")
        except subprocess.CalledProcessError:
            print "Problem executing command: " + cmd
            raise

    @staticmethod
    def _listFiles(pattern, search, pathsep=os.pathsep):
        for path in search.split(pathsep):
            for match in glob.glob(os.path.join(path,pattern)):
                if os.path.isfile(match):
                    yield match

    @staticmethod
    def _formatTime(totalSeconds):
        """ Show the given number of seconds in hr, min, sec """
        rv = ""
        if totalSeconds >= 3600:
            hr = int(totalSeconds / 3600)
            totalSeconds -= hr * 3600
            rv = str(hr) + " hr "
        min = int(totalSeconds / 60)
        if rv or min > 0:
            rv += str(min) + " min "
            totalSeconds -= min * 60
        rv += "%.2f sec" % totalSeconds
        return rv

    @staticmethod
    def msg(fileName, line, verbose=False):
        """ Log the given message; print if verbose is turned on. """
        fd = open(fileName, 'a')
        fd.write(line + '\n')
        fd.close()
        if verbose:
            print line

    @staticmethod 
    def removeIfExists(path):
        """ Utility method to delete file or directory if it exists. """
        if os.path.exists(path):
            if os.path.isdir(path):
                shutil.rmtree(path)
            else:
                os.remove(path)

    @staticmethod
    def addToFile(fileName, newValue):
        """ Utility method for appending a line to a file. """
        AVUtility.alterFile(fileName, actionType="append", newValue=newValue)

    @staticmethod
    def alterFile(fileName, actionType, originalValue=None, 
                                 newValue=None, mustExist=False):
        """ Utility method for editing, filtering, and appending to file. """
        if os.path.exists(fileName):
            if actionType == "filter" or actionType == "replace":
                for scriptLine in fileinput.FileInput(fileName, inplace=1):
                    if actionType == "filter":
                        if originalValue:
                            if not re.search(originalValue, scriptLine):
                                sys.stdout.write(scriptLine)
                        else:
                            raise ValueError("No original value to filter " +\
                                             "given.")
                    if actionType == "replace":
                        if originalValue and newValue:
                            scriptLine = re.sub(originalValue, newValue, 
                                                             scriptLine)
                            sys.stdout.write(scriptLine)
                        else:
                            raise ValueError("Original and new value fields" +\
                                             " incomplete.")
        elif mustExist:
            raise ValueError(fileName + " does not exist.")

        if actionType == "append":
            fileHandle = open(fileName, 'a+')
            fileHandle.write(newValue)
            fileHandle.close()

    @staticmethod
    def makeTempFile():
        (fileHandle, filePath) = tempfile.mkstemp()
        return fileHandle, filePath
    
    @staticmethod
    def genCMakeVarFiles(varDict):
        """
        Create a CMake precache file and include file.
        The include file is unfortunately necessary for multi-line variables.
        The CMake cache doesn't support them (stupid).
        """
      
        previousBuildFiles = [ 'CMakeCache.txt', 'precache', 'multiline.cmake' ]
        
        for fileName in previousBuildFiles:
            if os.path.isfile(fileName):
                raise ValueError('Error: ' + fileName +\
                                 ' has already been generated by CMake.' +\
                                 '  This means the installer ran here' +\
                                 ' previously. Remove build files and try' +\
                                 ' again.')
        
        pcHandle = open('precache', 'w')
        mlHandle = open('multiline.cmake', 'w') 

        # Escape dollar signs and backslashes in the variable's value.  
        # Otherwise it's treated as multiple variables and nonsense.
        
        escapeMap = { '$':'\$', '"':'\\"', '(':'\(', ')':'\)',
                      '#':'\#', '^':'\^' }
        
        for varName in varDict.keys():
            value = varDict[varName]
            for escChar in escapeMap.keys():
                value = value.replace(escChar, escapeMap[escChar])
            if '\n' in value:
                setLine = 'SET(' + varName + ' "' + value + '")\n\n'
                mlHandle.write(setLine)
            else:
                setLine = 'SET(' + varName + ' "' + value + '"' +\
                          '\n    CACHE STRING ' +\
                          '\n    "AVInstaller value for ' + varName + '")\n\n'
                pcHandle.write(setLine)

        pcHandle.close()
        mlHandle.close()
 
    @staticmethod
    def getCMakeCall(sourceTree='.', buildJobs='1'):
        """
        Return a string for calling the CMake build process.
        sourceTree (string) - Location of CMake source tree
        buildJobs (string) - Number of jobs to use in compile
        """

        return 'cmake -C precache ' + sourceTree
    
    @staticmethod
    def _hasAttribute(xmlElement, attribName):
        if attribName in xmlElement.attrib:
            return True
        else:
            return False
        
    @staticmethod
    def _getValidAttribute(xmlElement, attribName, valueRequired=False):
        if not attribName in xmlElement.attrib:
            if valueRequired:
                raise ValueError('Attribute ' + attribName + ' not in ' + \
                                 xmlElement.tag)
            else:
                return None
        elif not xmlElement.attrib[attribName] or \
            xmlElement.attrib[attribName].isspace():
            if valueRequired:
                raise ValueError('Blank or empty attribute ' + attribName + \
                                 ' in XML template.')
            else:
                return None
        else:
            return xmlElement.attrib[attribName]

    @staticmethod
    def _getValidText(xmlElement, valueRequired=False):
        if xmlElement is None:
            if valueRequired:
                raise ValueError('Received a None type for XML tag.')
            else:
                return None
        if not xmlElement.text or xmlElement.text.isspace():
            if valueRequired:
                raise ValueError('Blank or empty XML tag ' + xmlElement.tag + \
                                 ' in XML template.')
            else:
                return None
        else:
            return xmlElement.text.rstrip('\n')


    # Execute an SQL command
    # Arguments
    # databaseFile - file for database connection
    # dbCommand - SQL query to perform
    @staticmethod
    def runSQLCommand(databaseFile, dbCommand, sqlParams=()):
        dbConn = sqlite3.connect(databaseFile)
        dbCursor = dbConn.cursor()
        try:
            result = dbCursor.execute(dbCommand, sqlParams).fetchall()
        except sqlite3.OperationalError:
            print "Attempted SQL command: "
            print dbCommand
            raise
        dbConn.commit()
        dbConn.close()
        return result

    # Create an SQL table.
    # Arguments
    # databaseFile - name of file for connection
    # tableName - name of table to create
    # fields - list of fields for table
    @staticmethod
    def createSQLTable(databaseFile, tableName, fields):
        tableCreationString = "CREATE TABLE " + tableName + "("
        for i in range(len(fields)):
            if i > 0:
                tableCreationString += ', '
            tableCreationString += fields[i] + " text "
        tableCreationString += ")"

        AVUtility.runSQLCommand(databaseFile, tableCreationString)

    # Insert entry into SQL table.
    # Arguments
    # databaseFile - name of file for connection
    # tableName - name of table for adding entry
    # fields - list of fields for entry
    # values - list of values for entry
    @staticmethod
    def insertIntoSQLTable(databaseFile, tableName, fields, values):
        insertString = "INSERT INTO " + tableName + "("
        for i in range(len(fields)):
            if i > 0:
                insertString += ", "
            insertString += fields[i]
        insertString += ") VALUES("
        for i in range(len(values)):
            if i > 0:
                insertString += ", "
            insertString += "?"
        insertString += ")"
        sqlParams = tuple(values)
        AVUtility.runSQLCommand(databaseFile, insertString, sqlParams)

    ## Static utility method to select columns from table based on WHERE clause
    #  @param databaseFile File containing SQLite database.
    #  @param tableName Table to select from database.
    #  @param desiredColumns List of columns from which to pull data.
    #  @param whereClause String to append after SQLite WHERE
    #  @return List of tuples, where each tuple is a row of results
    @staticmethod
    def searchSQLTable(databaseFile, tableName, desiredColumns, whereClause):
        columnString = ''
        for i in range(len(desiredColumns)):
            if i > 0:
                columnString += ', '
            columnString += desiredColumns[i] 

        searchString = "SELECT " + columnString + " FROM " + tableName +\
                       " WHERE " + whereClause
        return AVUtility.runSQLCommand(databaseFile, searchString)

    ## Static utility method to select columns from table
    #  @param databaseFile File containing SQLite database.
    #  @param tableName Table to select from database.
    #  @param desiredColumns List of columns from which to pull data.
    #  @return List of tuples, where each tuple is a row of results
    @staticmethod
    def selectFromTable(databaseFile, tableName, desiredColumns):
        columnString = ''
        for i in range(len(desiredColumns)):
            if i > 0:
                columnString += ', '
            columnString += desiredColumns[i]

        selectString = "SELECT " + columnString + " FROM " + tableName
        return AVUtility.runSQLCommand(databaseFile, selectString)
